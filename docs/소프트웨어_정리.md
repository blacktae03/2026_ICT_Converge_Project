# 내가 해야할 것.

## 1. 센서 데이터 처리 및 물리량 변환

### a. $P_{dynamic}$ 에 대한 정보 어떻게 구할지 확실하게 알기

P_{dynamic}을 센서가 직접 알려주지는 않음.  
내가 쓸 센서가 정해지면 그 센서의 데이터시트를 참고해야함.  

데이터시트에는 *전압이 몇 V일 때 압력은 몇 Pa이다* 라는 기준이 존재함.  
이때 setup() 단계에서 초기 전압을 계산하고 offset을 따로 저장해두는 게 좋음.  
(바람이 아예 안 불 때 원래 2.5V라고 명시되어 있음에도, 실제로는 2.51V 정도로 노이즈가 있을 수 있음.)

int sensorValue = analogRead(PITOT_PIN);  
// 센서 전압을 압력(Pa)으로 변환 (센서 데이터시트 참고)  
float voltage = sensorValue * (5.0 / 1023.0);  
float pressurePa = (voltage - 2.5) * 1000.0; // 예시 보정값  
// 베르누이 공식으로 풍속(m/s) 변환  
if(pressurePa < 0) pressurePa = 0; // 노이즈 방지  
float velocity = sqrt((2 * pressurePa) / 1.225);  

약간 이런 식으로 센서 값을 읽고, 전압으로 변환하고, 데이터시트에 따라서 pressurePa를 구할 수 있는 것.

$$
\sqrt{\frac{2 \times P_{dynamic}}{\rho}}
$$

여기서 $\rho$ 는 1.225 정도의 대기압으로 고정해도 별 문제 없을 것으로 생각.  
나중에 고도나 온도에 따라 계산식을 적용하여 달리 할 거면 이것도 변수로 선언하는 게 좋음.

### b. 풍향에 대한 정보 어떻게 구할지 확실하게 알기

풍향은 비교적 친절함.  

0 ~ 4095 사이의 숫자를 0 ~ 360도로 매핑하면 됨.  
비례계산 때리면 됨.  
간단하게 비례식으로 표현하면

$$
angle = read \times \frac{360}{4095}
$$

## 2. 하이브리드 제어 알고리즘 구축

### a. 풍속에 따른 날개 각도 구하기

특정 풍속(x1), 풍향(x2)일 때 어떤 각도(y)를 날개가 가져야하는지를 판단해야 함.

일단, 다양한 풍속과 풍향 환경을 시뮬레이션하며 항력이 가장 최소가 되는 '정답 각도'를 일일이 기록한 데이터셋을 만들어야 함.  
데이터셋의 품질이 매우 중요하기 때문에 다양한 각도와 풍속에서 모든 데이터셋을 뽑을 수 있게 부탁해야함.

그 다음에 Polynomial Regression 써서 곡선으로 Regression 할 수 있게 모델 설계하면 될 듯.

Feature Scaling( $0 \le V \le 20, 0 \le \alpha \le 15$ , MinMaxScaler 사용하면 될 듯) 이랑 Regularization 적절하게 하고, $x_1\cdot x_2, x_1^2, x_2^2$ 이 정도 사용해보면 일단 완벽할 듯.

## 3. 실시간 임베디드 시스템 : 결정한 각도를 날개에 적용하는 과정

### a. 센서 데이터 샘플링 및 필터링

라즈베리파이의 GPIO를 사용해서 피토 튜브 (P_dynamic, 풍속 계산, ADC 필요), 풍향 센서(I2C)로부터 데이터를 주기적으로 가져오는 과정을 잘 구현해야 함.  

ADC(Analog-to-Digital Converter)가 필요한 이유 : 라즈베리파이는 아두이노와 달리 아날로그 입력 핀이 없다. 피토 튜브 센서(아날로그)를 쓰려면 MCP3008 같은 별도의 ADC 칩을 GPIO에 연결해야한다.

이때, 센서값이 요동치면 날개가 그 값을 계속 업데이트하려고 하니 덜덜 떨리면서 기계적 피로가 쌓인다. 이를 방지하기 위해서 이동 평균 필터(Moving Average Filter)나 저주파 통과 필터(Low Pass Filter)를 적용해 부드러운 입력값을 만들어야 함.

### b. 제어 루프 타이밍 관리

무인기가 하늘을 날면 환경이 급격하게 변하기 때문에 '인지-판단-구동'의 한 주기가 매우 빠르게 반복되어야한다.

파이썬은 OS 위에서 실행되므로 타이밍이 튈 수 있다. time.perf_counter() 등을 사용해서 루프가 20Hz ~ 50Hz 정도로 일정하게 유지되도록 관리해야 함.  
이때, 멀티프로세싱/쓰레딩 기법을 쓰면 병렬처리를 해서 더 안정적으로 50Hz를 유지 가능함.

센서 읽기, 모델 추론, 모터 제어 총 3단계가 어느 하나라도 밀리지 않도록 효율적인 루프 구조를 설계하는 것이 중요하다.

### c. 액추에이터 구동 및 안전장치

모델에서 추론한 y_pred를 PWM 신호로 변환해서 서보모터를 구동한다.

y_pred가 기계적 한계를 넘는 값이어도 하드웨어가 파손되지 않게 clip 처리를 반드시 해야함.

센서가 만약 제대로 작동 안해서 값이 안 들어오면 날개를 0도로 유지하는 예외 처리도 해야함.


## 도현이형 부탁

### 1. 이거 서보모터로 어떻게 밀고 댕겨서 날개를 트위스트할수 있을지 고민한번만 해주세욤

이건 내가 날개가 어떻게 움직이는지에 대한 설명을 조금 더 형한테 들어야 자세하게 찾아볼 수 있을 듯.

나는 이게 기체를 옆에서 바라봤을 때 시계 또는 반시계 방향으로 날개가 기울어지는 걸로 이해하고 있는데 맞는지 모르겠음.

### 2. 풍향풍속 삼차원으로 측정할수 있는 아이디어나 제품을 지피티와 인터넷으로 조사해주세용

Gemini한테 물어보니, IMU 센서의 값을 이용해야 더 정확한 값을 얻을 수 있다고 함.

AoA가 결국 중요한 거라서, 3차원 풍향을 얻을 필요는 없고, IMU 센서와 AoA 정보만 있으면 AoA를 기체의 기울어진 각도에 따라 더 정확하게 계산할 수 있음.

3차원 풍향을 얻을 필요가 없는 이유는, 기체의 AoA의 경우에는 Pitch (y축) 정보가 지배적이기 때문이다.

### 3. 날개모양이 바뀌어도 몸체가 방향을 안바꾸게 할수있는 아이디어도 조사해주세용

왼쪽, 오른쪽 날개가 항상 똑같은 각도로 같은 시간 내에 움직이게 해야함.

움직일 때도 한 번에 팍 움직이는 게 아니라 점진적으로 움직이게 코딩해야 함.

위에서 언급했던 센서가 제대로 작동안했을 때, 중립으로 날개를 조절하는 것도 필요함.

### 4. 마지막으로 풍향풍속에 따라 최적의 날개각도 찾아주는 시뮬레이터하는법도 조사해주세염

풍속, 풍향에 따른 최적의 날개 각도를 찾는 시뮬레이션을 돌리기 위해서는 아래 두 가지 프로그램 중 선택하면 된다고 함.

- XFLR5 (추천): 항공공학도들이 가장 많이 쓰는 가벼운 프로그램이야. 무인기 날개 형상을 넣고 풍속과 풍향을 바꿔가며 저항을 계산하기 좋아.
- Ansys Fluent: 매우 강력하지만 배우기 어렵고 사양이 높아. 공모전 수준에서는 XFLR5 정도로도 충분해.

시뮬레이션을 돌리는 방법 :

1. 변수 설정 : 풍속, 풍향, 기체 각도의 범위를 정한다. (예: 풍속 5~20m/s, 각도 0~15도)

2. 최적화 루프 : 특정 풍속, 풍향, 기체 각도 조건에서 날개 비틀림(y)을 0도 부터 20도 까지 1도 씩 바꿔가면서 시뮬레이터 돌린다.

3. 데이터 추출 : 그 중 항력(Drag) 수치가 가장 낮게 나온 각도를 기록하면 됨.

4. 이 때의 정보까지 종합해서 csv로 저장하면 됨. 그럼 머신러닝에 갖다 쓸 수 있음.

이때, 이 많은 경우의 수를 다 손으로 돌려보는 게 아니라 Batch Scripting이라는 기법을 써서 어느 정도 자동화가 가능하다고 함.

Batch Scripting이라는 기법을 더 자세하게 알고 싶으면 Gemini한테 아래처럼 질문하기 (기본적으로 이 공모전에 대한 프롬프트를 사용하고 있다고 가정)

풍향, 풍속, 기체 각도(IMU) 이 세 가지를 feature로 하는 머신러닝(Regression)을 진행하려고 해. 그래서 그에 상응하는 데이터셋을 마련해야 하는 상황이야. x1(풍향), x2(풍속), x3(기체 각도), y(최적의 날개 각도)에 해당하는 데이터셋을 얻기 위해서 XFLR5의 Batch Scripting을 사용하려고 하는데 어떻게 하는지 알려줘.

Gemini도 시뮬레이션 뿐만 아니라 실제 데이터로도 비교하는 걸 필요하다고 언급하고 있음.

시뮬레이션 부분은 필요하면 내가 알아보고 해봐도 될 듯? 도현이형의 판단에 맡길게

*참고 : 유체 해석 말고 구조 해석을 하고 싶으면 CREO 쓰면 됨.*